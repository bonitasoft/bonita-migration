import groovy.sql.Sql

subprojects {

    apply plugin: 'java'
    apply plugin: 'eclipse'
    apply plugin: 'maven'

    group = 'org.bonitasoft.migration'
    version = '1.24.3'

    sourceCompatibility = 1.6
    targetCompatibility = 1.6




    ext {
        migrationDistribClasses = '../bonita-migration-distrib/target/classes'
        migrationScriptsClasses = '../bonita-migration-scripts-integration-tests/target/classes'
        def split = project.name.split("@")[1].split("-")
        sourceversion = split[0]
        targetversion = split[1]
        dbvendor = System.getProperty("db.vendor", "postgres")
        dburl = System.getProperty("db.url", "jdbc:postgresql://localhost:5432/migration");
        dbuser = System.getProperty("db.user", "bonita")
        dbpassword = System.getProperty("db.password", "bpm")
        dbdriverClass = System.getProperty("db.driverClass", "org.postgresql.Driver")
        bonitahome = "${buildDir.path}/home"
        distDir = "${buildDir.path}/dist"
        devMode = project.hasProperty('devMode')
        //used for oracle: creates table not the same way
        //used for postgres: give a user able to drop and create databases
        dbRootUser = System.getProperty("db.root.user", "postgres")
        dbRootPassword = System.getProperty("db.root.password", "postgres")

        // Define variables:
        databaseName = "migration"
        serverName = "localhost"
        portNumber = "5432"
    }

    configurations {
        scriptsintegration
        sourcefiller
        migrationdist
        drivers
        homezip
        runmigration
    }

    repositories {
        flatDir name: 'localRepository', dirs: 'lib'
        //put the extra repo first: issue with gradle
        def customMavenRepoExtra = System.getProperty("maven.repository.extra")
        if (customMavenRepoExtra != null) {
            println "using custom maven.repository.extra: " + customMavenRepoExtra
            maven { url customMavenRepoExtra }
        }
        mavenLocal()
        def customMavenRepo = System.getProperty("maven.repository")
        //used in jenkins: add in system property $ {JENKINS_HOME}/userContent/m2_repo and archiva
        if (customMavenRepo != null) {
            println "using custom maven.repository: " + customMavenRepo
            maven { url customMavenRepo }
        }


        mavenCentral()
    }

    dependencies {
        if (targetversion.startsWith("7")) {
            sourcefiller "${group}:bonita-migration-${targetversion}-filler:${version}"
        } else {
            sourcefiller "${group}:bonita-migration-db-filler-${sourceversion}:${version}"
        }
        scriptsintegration "${group}:bonita-migration-scripts-integration-tests:${version}"
        homezip group: 'org.bonitasoft.engine', name: 'bonita-home', version: sourceversion, ext: 'zip'
        if (targetversion.startsWith("7")) {
            testCompile "${group}:bonita-migration-${targetversion}-checker:${version}"
        } else {
            testCompile "${group}:bonita-migration-db-filler-${targetversion}:${version}"
        }
        testCompile group: 'ch.qos.logback', name: 'logback-classic', version: '1.0.11'
        migrationdist group: group, name: "bonita-migration-distrib", version: "${version}", ext: 'zip'
        drivers group: 'mysql', name: 'mysql-connector-java', version: '5.1.26'
        drivers group: 'org.postgresql', name: 'postgresql', version: '9.3-1102-jdbc41'
        drivers name: 'ojdbc6'
        drivers name: 'sqljdbc-4.0.2206.100'
        runmigration group: 'com.thoughtworks.xstream', name: 'xstream', version: '1.4.2'
        runmigration group: 'commons-io', name: 'commons-io', version: '2.1'
        scriptsintegration configurations.drivers
        sourcefiller configurations.drivers
        testCompile group: 'junit', name: 'junit', version: '4.12'
        testCompile configurations.drivers
    }

//allow to execute sql from the build script -> see cleardb task
    URLClassLoader loader = GroovyObject.class.classLoader
    configurations.drivers.each { File file ->
        loader.addURL(file.toURI().toURL())
    }
//drop and create the database
    task cleardb << {
        println "Migration of $dbvendor"
        println "dbvendor business data dialect is $dbvendor"
        if (dbvendor.equals("oracle")) {
            println "cleaning oracle database $dbuser"
            if (dbRootUser == null || dbRootUser.isEmpty() || dbRootPassword == null || dbRootPassword.isEmpty()) {
                throw new IllegalStateException("must specify db.root.user and db.root.password for oracle")
            }
            def props = [user: dbRootUser, password: dbRootPassword] as Properties
            def sql = Sql.newInstance(dburl, props, dbdriverClass)
            sql.execute("""
                declare
                  v_count number;
                  v_banner varchar2(50) := 'Oracle Database 12c%';

                  cursor c1 is
                    select s.sid, s.serial#, s.username """
                    + ''' from gv$session s ''' + """
                    where s.type != 'BACKGROUND' and (upper(s.username) = upper('${
                dbuser
            }') OR upper(s.username) = upper('${
                dbuser
            }_bdm'));

                  cursor c2 is
                """
                    + ''' select v.banner from v$version v; '''
                    + """
                                    begin
                  -- disconnect sessions
                  for session_rec in c1
                  loop
                    execute immediate 'ALTER SYSTEM DISCONNECT SESSION session_rec.sid,session_rec.serial# IMMEDIATE';
                  end loop;

                  -- for oracle 12c
                  for cur_banner in c2 loop
                    if cur_banner.banner LIKE v_banner
                    then
                      execute immediate 'alter session set "_ORACLE_SCRIPT"=true';
                    end if;
                  end loop;


                  -- drop user if exists
                  select count(1) into v_count from dba_users where upper(username) = upper('${dbuser}');
                  if v_count != 0
                  then
                    execute immediate 'drop user ${dbuser} cascade';
                  end if;

                  select count(1) into v_count from dba_users where upper(username) = upper('${dbuser}_bdm');
                  if v_count != 0
                  then
                    execute immediate 'drop user ${dbuser}_bdm cascade';
                  end if;

                  -- recreate user
                  execute immediate 'CREATE USER ${dbuser} IDENTIFIED BY ${dbpassword}';
                  execute immediate 'ALTER USER ${dbuser} QUOTA 300M ON USERS';
                  execute immediate 'GRANT connect, resource TO ${dbuser}';
                  execute immediate 'GRANT select ON sys.dba_pending_transactions TO ${dbuser}';
                  execute immediate 'GRANT select ON sys.pending_trans\$ TO ${dbuser}';
                  execute immediate 'GRANT select ON sys.dba_2pc_pending TO ${dbuser}';
                  execute immediate 'GRANT execute ON sys.dbms_system TO ${dbuser}';

                  execute immediate 'CREATE USER ${dbuser}_bdm IDENTIFIED BY ${dbpassword}';
                  execute immediate 'ALTER USER ${dbuser}_bdm QUOTA 300M ON USERS';
                  execute immediate 'GRANT connect, resource TO ${dbuser}_bdm';
                  execute immediate 'GRANT select ON sys.dba_pending_transactions TO ${dbuser}_bdm';
                  execute immediate 'GRANT select ON sys.pending_trans\$ TO ${dbuser}_bdm';
                  execute immediate 'GRANT select ON sys.dba_2pc_pending TO ${dbuser}_bdm';
                  execute immediate 'GRANT execute ON sys.dbms_system TO ${dbuser}_bdm';
                end;
                """
            )
        } else if (dbvendor.equals("sqlserver")) {
            println "cleaning sqlserver database $dburl"
            if (dbRootUser == null || dbRootUser.isEmpty() || dbRootPassword == null || dbRootPassword.isEmpty()) {
                throw new IllegalStateException("must specify db.root.user and db.root.password for sqlserver")
            }

            def parsedUrl = (dburl =~ /(jdbc:\w+:\/\/)([\w\d\.-]+):(\d+);database=([\w-_\d]+).*/)
            project.serverName = parsedUrl[0][2]
            project.portNumber = parsedUrl[0][3]
            project.databaseName = parsedUrl[0][4]
            def genericUrl = parsedUrl[0][1] + serverName + ":" + portNumber
            println "recreate database $databaseName on server $serverName and port $portNumber with driver $dbdriverClass"
            println "url is  $genericUrl"
            def sql = Sql.newInstance(genericUrl, dbRootUser, dbRootPassword, dbdriverClass)
            def script = file("init-sqlserver.sql").text
            script = script.replace("@sqlserver.db.name@", databaseName)
            script = script.replace("@sqlserver.connection.username@", dbuser)
            script = script.replace("@sqlserver.connection.password@", dbpassword)
            script.split("GO").each { sql.executeUpdate(it) }
            sql.close()
        } else {
            println "drop and create: $dburl"
            def parsedUrl = (dburl =~ /(jdbc:\w+:\/\/)([\w\d\.-]+):(\d+)\/([\w-_\d]+).*/)
            project.serverName = parsedUrl[0][2]
            project.portNumber = parsedUrl[0][3]
            project.databaseName = parsedUrl[0][4]
            def genericUrl = parsedUrl[0][1] + serverName + ":" + portNumber + "/"
            println "recreate database $databaseName on server $serverName and port $portNumber with driver $dbdriverClass"
            println "url is  $genericUrl"
            if (dbvendor.equals("postgres")) {
                println "cleaning postgres database $databaseName"
                if (dbRootUser == null || dbRootUser.isEmpty() || dbRootPassword == null || dbRootPassword.isEmpty()) {
                    throw new IllegalStateException("must specify db.root.user and db.root.password for postgres")
                }
                def sql = Sql.newInstance(genericUrl, dbRootUser, dbRootPassword, dbdriverClass)
                // postgres 9.3 script version
                sql.eachRow("""
                    SELECT pid
                    FROM pg_stat_activity
                    WHERE upper(pg_stat_activity.datname) = upper('$databaseName')
                      AND pid <> pg_backend_pid()
                    """ as String) {
                    logger.info("disconnect connexion id $it.pid from database $databaseName")
                    sql.execute("""
                    SELECT pg_terminate_backend(pg_stat_activity.pid)
                    FROM pg_stat_activity
                    WHERE pg_stat_activity.datname = '$databaseName'
                    AND pid = $it.pid
                        """ as String)
                }

                sql.executeUpdate("DROP DATABASE IF EXISTS $databaseName;".toString())
                sql.executeUpdate("CREATE DATABASE $databaseName OWNER $dbuser;".toString())
                sql.executeUpdate("GRANT ALL PRIVILEGES ON DATABASE $databaseName TO $dbuser;".toString())
                sql.close()
            } else {
                if (dbRootUser == null || dbRootUser.isEmpty() || dbRootPassword == null || dbRootPassword.isEmpty() || databaseName == null || databaseName.isEmpty()) {
                    throw new IllegalStateException("must specify db.databaseName,  db.root.user and db.root.password  for mysql")
                }
                def sql = Sql.newInstance(genericUrl, dbRootUser, dbRootPassword, dbdriverClass)
                sql.executeUpdate("DROP DATABASE IF EXISTS " + databaseName)
                sql.eachRow("select distinct user from mysql.user where user ='" + databaseName + "'") {
                    sql.executeUpdate("DROP USER " + dbuser)
                }
                sql.executeUpdate("CREATE USER " + dbuser + " IDENTIFIED BY '" + dbpassword + "'")
                sql.executeUpdate("CREATE DATABASE " + databaseName + " DEFAULT CHARACTER SET utf8")
                sql.executeUpdate("GRANT ALL ON " + databaseName + ".* TO " + dbuser)
                sql.close()
            }
        }
    }
    task unpackhome(dependsOn: cleardb, type: Copy) {
        def zipFile = configurations.homezip.files.iterator().next()
        def outputDir = file("${buildDir.path}")

        from zipTree(zipFile)
        into outputDir
    }

    task unpackdist(dependsOn: unpackhome, type: Copy) {
        def zipFile = configurations.migrationdist.files.iterator().next()
        def outputDir = file(distDir)

        from zipTree(zipFile)
        into outputDir
    }

    task overwritedist(dependsOn: unpackdist, type: Copy) {
//    def zipFile = configurations.migrationdist.files.iterator().next()
        //devMode = hasProperty('devMode')
        if (project.hasProperty('devMode') && devMode) {
            println """
***************************************
************** DEV MODE ***************
** overwriting files of distrib with :*
 - $migrationDistribClasses
 - $migrationScriptsClasses
***************************************
***************************************
"""
            def outputDir = file(distDir)

            from files(migrationDistribClasses)
            from files(migrationScriptsClasses)
            into outputDir
        }
    }
    task copyDrivers(dependsOn: overwritedist, type: Copy) {
        into "$distDir/lib"
        from configurations.drivers
    }

    task changeproperties(dependsOn: copyDrivers) << {
        def propFile = new File(distDir, "Config.properties")
        def fis = new FileInputStream(propFile)
        def Properties props = new Properties()
        props.load(fis)
        fis.close()
        props.put("source.version", String.valueOf(sourceversion))
        props.put("target.version", String.valueOf(targetversion))
        props.put("db.vendor", String.valueOf(dbvendor));
        props.put("db.url", String.valueOf(dburl));
        props.put("db.user", String.valueOf(dbuser));
        props.put("db.password", String.valueOf(dbpassword));
        props.put("db.driverClass", String.valueOf(dbdriverClass));
        props.put("bonita.home", String.valueOf(bonitahome));
        props.store(new FileWriter(propFile), "config");
    }

    task scriptsintegration(dependsOn: changeproperties, type: JavaExec) {
        doFirst {
            println "run scripts integration tests"
            systemProperties(["sysprop.bonita.db.vendor": dbvendor,
                              "db.vendor"               : dbvendor,
                              "jdbc.vendor"             : dbvendor,
                              "jdbc.url"                : dburl,
                              "jdbc.user"               : dbuser,
                              "jdbc.password"           : dbpassword,
                              "jdbc.driverClass"        : dbdriverClass,
                              "jdbc.serverName"         : project.serverName,
                              "jdbc.portNumber"         : project.portNumber,
                              "jdbc.databaseName"       : project.databaseName,
                              "bonita.home"             : bonitahome])
            println systemProperties
            main = "org.bonitasoft.migration.DBUnitTestSuite"
        }
        classpath configurations.scriptsintegration

    }

    task execfill(dependsOn: scriptsintegration, type: JavaExec) {
        doFirst {
            println "execute fill of the database using classpath of $sourceversion"
            systemProperties(["sysprop.bonita.db.vendor"    : dbvendor,
                              "db.vendor"                   : dbvendor,
                              "jdbc.vendor"                 : dbvendor,
                              "jdbc.url"                    : dburl,
                              "jdbc.user"                   : dbuser,
                              "jdbc.password"               : dbpassword,
                              "jdbc.driverClass"            : dbdriverClass,
                              "jdbc.serverName"             : project.serverName,
                              "jdbc.portNumber"             : project.portNumber,
                              "jdbc.databaseName"           : project.databaseName,
                              "db.url"                      : dburl,
                              "db.user"                     : dbuser,
                              "db.password"                 : dbpassword,
                              "db.driver.class"             : dbdriverClass,
                              "db.server.name"              : project.serverName,
                              "db.server.port"              : project.portNumber,
                              "db.database.name"            : project.databaseName,
                              "bonita.home"                 : bonitahome,
                              "sysprop.bonita.bdm.db.vendor": dbvendor])
            /*jvmArgs([
                "-Xdebug",
                "-Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000"
                ])*/
            println systemProperties

            if (targetversion.startsWith("7")) {
                main = "org.bonitasoft.migration.DatabaseFillerFor${targetversion.replace('.', '_')}"
            } else {
                main = "org.bonitasoft.migration.DatabaseFiller${sourceversion.replace('.', '_')}"
            }
        }
        classpath configurations.sourcefiller

    }


    task runmigration(dependsOn: execfill, type: JavaExec) {
        workingDir distDir
        main = 'groovy.lang.GroovyShell'
        classpath = files([
                "build/dist/lib/groovy-all-1.8.6.jar"
        ] as String[], configurations.runmigration)
        args 'Migration.groovy'
        systemProperty 'auto.accept', 'true'
    }

    task postmigrationtests(dependsOn: runmigration, type: JavaExec) {
        doFirst {
            println "run post-migration integration tests scripts"
            systemProperties(["bonita.home"   : bonitahome,
                              "target.version": targetversion])
            println systemProperties
            main = "org.bonitasoft.migration.postmigration.PostMigrationTest"
        }
        classpath configurations.scriptsintegration
    }

    test.dependsOn(postmigrationtests)
    test {
        doFirst {
            println "execute test of the database using classpath of $targetversion"
            systemProperties(["sysprop.bonita.db.vendor"    : dbvendor,
                              "db.vendor"                   : dbvendor,
                              "jdbc.vendor"                 : dbvendor,
                              "jdbc.url"                    : dburl,
                              "jdbc.user"                   : dbuser,
                              "jdbc.password"               : dbpassword,
                              "jdbc.driverClass"            : dbdriverClass,
                              "jdbc.serverName"             : project.serverName,
                              "jdbc.portNumber"             : project.portNumber,
                              "jdbc.databaseName"           : project.databaseName,
                              "db.url"                      : dburl,
                              "db.user"                     : dbuser,
                              "db.password"                 : dbpassword,
                              "db.driver.class"             : dbdriverClass,
                              "db.server.name"              : project.serverName,
                              "db.server.port"              : project.portNumber,
                              "db.database.name"            : project.databaseName,
                              "bonita.home"                 : bonitahome,
                              "target.version"              : targetversion,
                              "logback.configurationFile"   : file("logback.xml").getAbsolutePath(),
                              "sysprop.bonita.bdm.db.vendor": dbvendor])
            /*jvmArgs([
                "-Xdebug",
                "-Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000"
                ])*/
            println systemProperties
        }
        testLogging.showStandardStreams = true
    }

}
